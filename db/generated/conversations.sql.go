// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: conversations.sql

package generated

import (
	"context"
)

const archiveConversation = `-- name: ArchiveConversation :one
UPDATE conversations
SET archived = TRUE, updated_at = CURRENT_TIMESTAMP
WHERE conversation_id = ?
RETURNING conversation_id, slug, user_initiated, created_at, updated_at, cwd, archived, agent_working, context_window_size, agent_error, github_urls, git_origin
`

func (q *Queries) ArchiveConversation(ctx context.Context, conversationID string) (Conversation, error) {
	row := q.db.QueryRowContext(ctx, archiveConversation, conversationID)
	var i Conversation
	err := row.Scan(
		&i.ConversationID,
		&i.Slug,
		&i.UserInitiated,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Cwd,
		&i.Archived,
		&i.AgentWorking,
		&i.ContextWindowSize,
		&i.AgentError,
		&i.GithubUrls,
		&i.GitOrigin,
	)
	return i, err
}

const countArchivedConversations = `-- name: CountArchivedConversations :one
SELECT COUNT(*) FROM conversations WHERE archived = TRUE
`

func (q *Queries) CountArchivedConversations(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countArchivedConversations)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countConversations = `-- name: CountConversations :one
SELECT COUNT(*) FROM conversations WHERE archived = FALSE
`

func (q *Queries) CountConversations(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countConversations)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createConversation = `-- name: CreateConversation :one
INSERT INTO conversations (conversation_id, slug, user_initiated, cwd, git_origin)
VALUES (?, ?, ?, ?, ?)
RETURNING conversation_id, slug, user_initiated, created_at, updated_at, cwd, archived, agent_working, context_window_size, agent_error, github_urls, git_origin
`

type CreateConversationParams struct {
	ConversationID string  `json:"conversation_id"`
	Slug           *string `json:"slug"`
	UserInitiated  bool    `json:"user_initiated"`
	Cwd            *string `json:"cwd"`
	GitOrigin      *string `json:"git_origin"`
}

func (q *Queries) CreateConversation(ctx context.Context, arg CreateConversationParams) (Conversation, error) {
	row := q.db.QueryRowContext(ctx, createConversation,
		arg.ConversationID,
		arg.Slug,
		arg.UserInitiated,
		arg.Cwd,
		arg.GitOrigin,
	)
	var i Conversation
	err := row.Scan(
		&i.ConversationID,
		&i.Slug,
		&i.UserInitiated,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Cwd,
		&i.Archived,
		&i.AgentWorking,
		&i.ContextWindowSize,
		&i.AgentError,
		&i.GithubUrls,
		&i.GitOrigin,
	)
	return i, err
}

const deleteConversation = `-- name: DeleteConversation :exec
DELETE FROM conversations
WHERE conversation_id = ?
`

func (q *Queries) DeleteConversation(ctx context.Context, conversationID string) error {
	_, err := q.db.ExecContext(ctx, deleteConversation, conversationID)
	return err
}

const getConversation = `-- name: GetConversation :one
SELECT conversation_id, slug, user_initiated, created_at, updated_at, cwd, archived, agent_working, context_window_size, agent_error, github_urls, git_origin FROM conversations
WHERE conversation_id = ?
`

func (q *Queries) GetConversation(ctx context.Context, conversationID string) (Conversation, error) {
	row := q.db.QueryRowContext(ctx, getConversation, conversationID)
	var i Conversation
	err := row.Scan(
		&i.ConversationID,
		&i.Slug,
		&i.UserInitiated,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Cwd,
		&i.Archived,
		&i.AgentWorking,
		&i.ContextWindowSize,
		&i.AgentError,
		&i.GithubUrls,
		&i.GitOrigin,
	)
	return i, err
}

const getConversationBySlug = `-- name: GetConversationBySlug :one
SELECT conversation_id, slug, user_initiated, created_at, updated_at, cwd, archived, agent_working, context_window_size, agent_error, github_urls, git_origin FROM conversations
WHERE slug = ?
`

func (q *Queries) GetConversationBySlug(ctx context.Context, slug *string) (Conversation, error) {
	row := q.db.QueryRowContext(ctx, getConversationBySlug, slug)
	var i Conversation
	err := row.Scan(
		&i.ConversationID,
		&i.Slug,
		&i.UserInitiated,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Cwd,
		&i.Archived,
		&i.AgentWorking,
		&i.ContextWindowSize,
		&i.AgentError,
		&i.GithubUrls,
		&i.GitOrigin,
	)
	return i, err
}

const listArchivedConversations = `-- name: ListArchivedConversations :many
SELECT conversation_id, slug, user_initiated, created_at, updated_at, cwd, archived, agent_working, context_window_size, agent_error, github_urls, git_origin FROM conversations
WHERE archived = TRUE
ORDER BY updated_at DESC
LIMIT ? OFFSET ?
`

type ListArchivedConversationsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListArchivedConversations(ctx context.Context, arg ListArchivedConversationsParams) ([]Conversation, error) {
	rows, err := q.db.QueryContext(ctx, listArchivedConversations, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Conversation{}
	for rows.Next() {
		var i Conversation
		if err := rows.Scan(
			&i.ConversationID,
			&i.Slug,
			&i.UserInitiated,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Cwd,
			&i.Archived,
			&i.AgentWorking,
			&i.ContextWindowSize,
			&i.AgentError,
			&i.GithubUrls,
			&i.GitOrigin,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listConversations = `-- name: ListConversations :many
SELECT conversation_id, slug, user_initiated, created_at, updated_at, cwd, archived, agent_working, context_window_size, agent_error, github_urls, git_origin FROM conversations
WHERE archived = FALSE
ORDER BY updated_at DESC
LIMIT ? OFFSET ?
`

type ListConversationsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListConversations(ctx context.Context, arg ListConversationsParams) ([]Conversation, error) {
	rows, err := q.db.QueryContext(ctx, listConversations, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Conversation{}
	for rows.Next() {
		var i Conversation
		if err := rows.Scan(
			&i.ConversationID,
			&i.Slug,
			&i.UserInitiated,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Cwd,
			&i.Archived,
			&i.AgentWorking,
			&i.ContextWindowSize,
			&i.AgentError,
			&i.GithubUrls,
			&i.GitOrigin,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchArchivedConversations = `-- name: SearchArchivedConversations :many
SELECT conversation_id, slug, user_initiated, created_at, updated_at, cwd, archived, agent_working, context_window_size, agent_error, github_urls, git_origin FROM conversations
WHERE slug LIKE '%' || ? || '%' AND archived = TRUE
ORDER BY updated_at DESC
LIMIT ? OFFSET ?
`

type SearchArchivedConversationsParams struct {
	Column1 *string `json:"column_1"`
	Limit   int64   `json:"limit"`
	Offset  int64   `json:"offset"`
}

func (q *Queries) SearchArchivedConversations(ctx context.Context, arg SearchArchivedConversationsParams) ([]Conversation, error) {
	rows, err := q.db.QueryContext(ctx, searchArchivedConversations, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Conversation{}
	for rows.Next() {
		var i Conversation
		if err := rows.Scan(
			&i.ConversationID,
			&i.Slug,
			&i.UserInitiated,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Cwd,
			&i.Archived,
			&i.AgentWorking,
			&i.ContextWindowSize,
			&i.AgentError,
			&i.GithubUrls,
			&i.GitOrigin,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchConversations = `-- name: SearchConversations :many
SELECT conversation_id, slug, user_initiated, created_at, updated_at, cwd, archived, agent_working, context_window_size, agent_error, github_urls, git_origin FROM conversations
WHERE slug LIKE '%' || ? || '%' AND archived = FALSE
ORDER BY updated_at DESC
LIMIT ? OFFSET ?
`

type SearchConversationsParams struct {
	Column1 *string `json:"column_1"`
	Limit   int64   `json:"limit"`
	Offset  int64   `json:"offset"`
}

func (q *Queries) SearchConversations(ctx context.Context, arg SearchConversationsParams) ([]Conversation, error) {
	rows, err := q.db.QueryContext(ctx, searchConversations, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Conversation{}
	for rows.Next() {
		var i Conversation
		if err := rows.Scan(
			&i.ConversationID,
			&i.Slug,
			&i.UserInitiated,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Cwd,
			&i.Archived,
			&i.AgentWorking,
			&i.ContextWindowSize,
			&i.AgentError,
			&i.GithubUrls,
			&i.GitOrigin,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const unarchiveConversation = `-- name: UnarchiveConversation :one
UPDATE conversations
SET archived = FALSE, updated_at = CURRENT_TIMESTAMP
WHERE conversation_id = ?
RETURNING conversation_id, slug, user_initiated, created_at, updated_at, cwd, archived, agent_working, context_window_size, agent_error, github_urls, git_origin
`

func (q *Queries) UnarchiveConversation(ctx context.Context, conversationID string) (Conversation, error) {
	row := q.db.QueryRowContext(ctx, unarchiveConversation, conversationID)
	var i Conversation
	err := row.Scan(
		&i.ConversationID,
		&i.Slug,
		&i.UserInitiated,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Cwd,
		&i.Archived,
		&i.AgentWorking,
		&i.ContextWindowSize,
		&i.AgentError,
		&i.GithubUrls,
		&i.GitOrigin,
	)
	return i, err
}

const updateConversationAgentError = `-- name: UpdateConversationAgentError :exec
UPDATE conversations
SET agent_error = ?, updated_at = CURRENT_TIMESTAMP
WHERE conversation_id = ?
`

type UpdateConversationAgentErrorParams struct {
	AgentError     bool   `json:"agent_error"`
	ConversationID string `json:"conversation_id"`
}

func (q *Queries) UpdateConversationAgentError(ctx context.Context, arg UpdateConversationAgentErrorParams) error {
	_, err := q.db.ExecContext(ctx, updateConversationAgentError, arg.AgentError, arg.ConversationID)
	return err
}

const updateConversationAgentWorking = `-- name: UpdateConversationAgentWorking :exec
UPDATE conversations
SET agent_working = ?, updated_at = CURRENT_TIMESTAMP
WHERE conversation_id = ?
`

type UpdateConversationAgentWorkingParams struct {
	AgentWorking   bool   `json:"agent_working"`
	ConversationID string `json:"conversation_id"`
}

func (q *Queries) UpdateConversationAgentWorking(ctx context.Context, arg UpdateConversationAgentWorkingParams) error {
	_, err := q.db.ExecContext(ctx, updateConversationAgentWorking, arg.AgentWorking, arg.ConversationID)
	return err
}

const updateConversationContextWindowSize = `-- name: UpdateConversationContextWindowSize :exec
UPDATE conversations
SET context_window_size = ?, updated_at = CURRENT_TIMESTAMP
WHERE conversation_id = ?
`

type UpdateConversationContextWindowSizeParams struct {
	ContextWindowSize int64  `json:"context_window_size"`
	ConversationID    string `json:"conversation_id"`
}

func (q *Queries) UpdateConversationContextWindowSize(ctx context.Context, arg UpdateConversationContextWindowSizeParams) error {
	_, err := q.db.ExecContext(ctx, updateConversationContextWindowSize, arg.ContextWindowSize, arg.ConversationID)
	return err
}

const updateConversationCwd = `-- name: UpdateConversationCwd :one
UPDATE conversations
SET cwd = ?, updated_at = CURRENT_TIMESTAMP
WHERE conversation_id = ?
RETURNING conversation_id, slug, user_initiated, created_at, updated_at, cwd, archived, agent_working, context_window_size, agent_error, github_urls, git_origin
`

type UpdateConversationCwdParams struct {
	Cwd            *string `json:"cwd"`
	ConversationID string  `json:"conversation_id"`
}

func (q *Queries) UpdateConversationCwd(ctx context.Context, arg UpdateConversationCwdParams) (Conversation, error) {
	row := q.db.QueryRowContext(ctx, updateConversationCwd, arg.Cwd, arg.ConversationID)
	var i Conversation
	err := row.Scan(
		&i.ConversationID,
		&i.Slug,
		&i.UserInitiated,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Cwd,
		&i.Archived,
		&i.AgentWorking,
		&i.ContextWindowSize,
		&i.AgentError,
		&i.GithubUrls,
		&i.GitOrigin,
	)
	return i, err
}

const updateConversationCwdAndGitOrigin = `-- name: UpdateConversationCwdAndGitOrigin :one
UPDATE conversations
SET cwd = ?, git_origin = ?, updated_at = CURRENT_TIMESTAMP
WHERE conversation_id = ?
RETURNING conversation_id, slug, user_initiated, created_at, updated_at, cwd, archived, agent_working, context_window_size, agent_error, github_urls, git_origin
`

type UpdateConversationCwdAndGitOriginParams struct {
	Cwd            *string `json:"cwd"`
	GitOrigin      *string `json:"git_origin"`
	ConversationID string  `json:"conversation_id"`
}

func (q *Queries) UpdateConversationCwdAndGitOrigin(ctx context.Context, arg UpdateConversationCwdAndGitOriginParams) (Conversation, error) {
	row := q.db.QueryRowContext(ctx, updateConversationCwdAndGitOrigin, arg.Cwd, arg.GitOrigin, arg.ConversationID)
	var i Conversation
	err := row.Scan(
		&i.ConversationID,
		&i.Slug,
		&i.UserInitiated,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Cwd,
		&i.Archived,
		&i.AgentWorking,
		&i.ContextWindowSize,
		&i.AgentError,
		&i.GithubUrls,
		&i.GitOrigin,
	)
	return i, err
}

const updateConversationGitHubUrls = `-- name: UpdateConversationGitHubUrls :exec
UPDATE conversations
SET github_urls = ?, updated_at = CURRENT_TIMESTAMP
WHERE conversation_id = ?
`

type UpdateConversationGitHubUrlsParams struct {
	GithubUrls     *string `json:"github_urls"`
	ConversationID string  `json:"conversation_id"`
}

func (q *Queries) UpdateConversationGitHubUrls(ctx context.Context, arg UpdateConversationGitHubUrlsParams) error {
	_, err := q.db.ExecContext(ctx, updateConversationGitHubUrls, arg.GithubUrls, arg.ConversationID)
	return err
}

const updateConversationSlug = `-- name: UpdateConversationSlug :one
UPDATE conversations
SET slug = ?, updated_at = CURRENT_TIMESTAMP
WHERE conversation_id = ?
RETURNING conversation_id, slug, user_initiated, created_at, updated_at, cwd, archived, agent_working, context_window_size, agent_error, github_urls, git_origin
`

type UpdateConversationSlugParams struct {
	Slug           *string `json:"slug"`
	ConversationID string  `json:"conversation_id"`
}

func (q *Queries) UpdateConversationSlug(ctx context.Context, arg UpdateConversationSlugParams) (Conversation, error) {
	row := q.db.QueryRowContext(ctx, updateConversationSlug, arg.Slug, arg.ConversationID)
	var i Conversation
	err := row.Scan(
		&i.ConversationID,
		&i.Slug,
		&i.UserInitiated,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Cwd,
		&i.Archived,
		&i.AgentWorking,
		&i.ContextWindowSize,
		&i.AgentError,
		&i.GithubUrls,
		&i.GitOrigin,
	)
	return i, err
}

const updateConversationTimestamp = `-- name: UpdateConversationTimestamp :exec
UPDATE conversations
SET updated_at = CURRENT_TIMESTAMP
WHERE conversation_id = ?
`

func (q *Queries) UpdateConversationTimestamp(ctx context.Context, conversationID string) error {
	_, err := q.db.ExecContext(ctx, updateConversationTimestamp, conversationID)
	return err
}
