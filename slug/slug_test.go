package slug

import (
	"context"
	"fmt"
	"log/slog"
	"os"
	"testing"

	"shelley.exe.dev/db"
	"shelley.exe.dev/llm"
)

func TestSanitize(t *testing.T) {
	tests := []struct {
		input    string
		expected string
	}{
		{"Simple Test", "Simple Test"},
		{"Create a Python Script", "Create a Python Script"},
		{"Multiple   Spaces", "Multiple Spaces"},
		{"Special@#$%Characters", "Special@#$%Characters"},
		{"日本語タイトル", "日本語タイトル"},
		{"English and 日本語 mixed", "English and 日本語 mixed"},
		{"   leading and trailing   ", "leading and trailing"},
		{"", ""},
		{"Very Long Title That Might Need To Be Truncated Because It Is Too Long For Normal Use Cases", "Very Long Title That Might Need To Be Truncated Because It I"},
	}

	for _, test := range tests {
		result := Sanitize(test.input)
		if result != test.expected {
			t.Errorf("Sanitize(%q) = %q, expected %q", test.input, result, test.expected)
		}
	}
}

// TestGenerateSlug_UniquenessSuffix tests that slug generation adds numeric suffixes when there are conflicts
func TestGenerateSlug_UniquenessSuffix(t *testing.T) {
	// Test that numeric suffixes would be correctly formatted
	// This mimics what the GenerateSlug function does internally
	tests := []struct {
		baseSlug string
		attempt  int
		expected string
	}{
		{"test message", 0, "test message-1"},
		{"test message", 1, "test message-2"},
		{"test message", 2, "test message-3"},
		{"help python", 9, "help python-10"},
	}

	for _, test := range tests {
		result := fmt.Sprintf("%s-%d", test.baseSlug, test.attempt+1)
		if result != test.expected {
			t.Errorf("Suffix generation failed: got %q, expected %q", result, test.expected)
		}
	}
}

// MockLLMService provides a mock LLM service for testing
type MockLLMService struct {
	ResponseText string
}

func (m *MockLLMService) Do(ctx context.Context, req *llm.Request) (*llm.Response, error) {
	return &llm.Response{
		Content: []llm.Content{
			{Type: llm.ContentTypeText, Text: m.ResponseText},
		},
	}, nil
}

func (m *MockLLMService) TokenContextWindow() int {
	return 8192 // Mock token limit
}

func (m *MockLLMService) MaxImageDimension() int {
	return 0 // No limit for mock
}

// MockLLMProvider provides a mock LLM provider for testing
type MockLLMProvider struct {
	Service *MockLLMService
}

func (m *MockLLMProvider) GetService(modelID string) (llm.Service, error) {
	return m.Service, nil
}

// TestGenerateSlug_DatabaseIntegration tests slug generation with actual database conflicts
func TestGenerateSlug_DatabaseIntegration(t *testing.T) {
	// Create temporary database
	tempDB := t.TempDir() + "/slug_test.db"
	database, err := db.New(db.Config{DSN: tempDB})
	if err != nil {
		t.Fatalf("Failed to create test database: %v", err)
	}
	defer database.Close()

	// Run migrations
	ctx := context.Background()
	if err := database.Migrate(ctx); err != nil {
		t.Fatalf("Failed to migrate database: %v", err)
	}

	// Create mock LLM provider that always returns the same title
	mockLLM := &MockLLMProvider{
		Service: &MockLLMService{
			ResponseText: "test title", // Always return the same title to force conflicts
		},
	}

	// Create logger (silent for tests)
	logger := slog.New(slog.NewTextHandler(os.Stdout, &slog.HandlerOptions{
		Level: slog.LevelWarn, // Only show warnings and errors
	}))

	// Create first conversation to establish the base slug
	conv1, err := database.CreateConversation(ctx, nil, true, nil, nil)
	if err != nil {
		t.Fatalf("Failed to create first conversation: %v", err)
	}

	// Generate first slug - should succeed with "test title"
	slug1, err := GenerateSlug(ctx, mockLLM, database, logger, conv1.ConversationID, "Test message", "")
	if err != nil {
		t.Fatalf("Failed to generate first slug: %v", err)
	}
	if slug1 != "test title" {
		t.Errorf("Expected first slug to be 'test title', got %q", slug1)
	}

	// Create second conversation
	conv2, err := database.CreateConversation(ctx, nil, true, nil, nil)
	if err != nil {
		t.Fatalf("Failed to create second conversation: %v", err)
	}

	// Generate second slug - should get "test title-1" due to conflict
	slug2, err := GenerateSlug(ctx, mockLLM, database, logger, conv2.ConversationID, "Test message", "")
	if err != nil {
		t.Fatalf("Failed to generate second slug: %v", err)
	}
	if slug2 != "test title-1" {
		t.Errorf("Expected second slug to be 'test title-1', got %q", slug2)
	}

	// Create third conversation
	conv3, err := database.CreateConversation(ctx, nil, true, nil, nil)
	if err != nil {
		t.Fatalf("Failed to create third conversation: %v", err)
	}

	// Generate third slug - should get "test title-2" due to conflict
	slug3, err := GenerateSlug(ctx, mockLLM, database, logger, conv3.ConversationID, "Test message", "")
	if err != nil {
		t.Fatalf("Failed to generate third slug: %v", err)
	}
	if slug3 != "test title-2" {
		t.Errorf("Expected third slug to be 'test title-2', got %q", slug3)
	}

	// Verify all slugs are different
	if slug1 == slug2 || slug1 == slug3 || slug2 == slug3 {
		t.Errorf("All slugs should be unique: slug1=%q, slug2=%q, slug3=%q", slug1, slug2, slug3)
	}

	t.Logf("Successfully generated unique slugs: %q, %q, %q", slug1, slug2, slug3)
}
